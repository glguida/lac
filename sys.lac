(define defun (macro (name binds body) `(define ,name (labels ,name ,binds ,body))))
(define defmacro (macro (name binds body) `(define ,name (macro ,binds ,body))))

(define NIL ())
(defun null (x) (eq x NIL))

(defun caar (x) (car (car x)))
(defun cadr (x) (car (cdr x)))
(defun cdar (x) (cdr (car x)))
(defun cddr (x) (cdr (cdr x)))
(defun caaar (x) (car (car (car x))))
(defun caadr (x) (car (car (cdr x))))
(defun cadar (x) (car (cdr (car x))))
(defun caddr (x) (car (cdr (cdr x))))
(defun cdaar (x) (cdr (car (car x))))
(defun cdadr (x) (cdr (car (cdr x))))
(defun cddar (x) (cdr (cdr (car x))))
(defun cdddr (x) (cdr (cdr (cdr x))))

(defun first (l) (car l))
(defun second (l) (first (cdr l)))
(defun third (l) (second (cdr l)))
(defun fourth (l) (third (cdr l)))
(defun fifth (l) (fourth (cdr l)))
(defun sixth (l) (fifth (cdr l)))
(defun seventh (l) (sixth (cdr l)))
(defun eighth (l) (seventh (cdr l)))
(defun ninth (l) (eighth (cdr l)))
(defun tenth (l) (ninth (cdr l)))

(defmacro let (binds &rest body) 
  `((lambda ,(mapcar car binds) ,@body)
    ,@(mapcar cadr binds)))

(defmacro if (test true false)
  `(cond (,test ,true) (t ,false)))

(defmacro or (x &rest y)
  (let ((g (gensym)))
    `(let ((,g ,x))
       (if ,g ,g  (if (null ',y) NIL (or ,@y))))))

(defmacro and (x &rest y)
  (let ((g (gensym)))
    `(let ((,g ,x))
       (if ,g (if (null ',y) ,g (and ,@y)) ,g))))

(defun listp (x) (or (nullp x) (consp x)))

(defun nth (n l)
  (cond 
    ((eq n 0) (car l))
    (t (nth (- n 1) (cdr l)))))


(defmacro setq (sym val) 
  `(set (quote ,sym) ,val))

(defun 1+ (x) (+ 1 x))
(defun 1- (x) (- x 1))
(defun evenp (x) (eq (% x 2) 0))
(defun oddp (x) (eq (% x 2) 1))
(defmacro incf (x) `(setq ,x (1+ ,x)))
(defmacro decf (x) `(setq ,x (1- ,x)))

(defun equal (x y) 
  (cond
    ((and (stringp x) (stringp y)) (string-equal x y))
    (t                             (eq x y))))
       

(load "examples.lac")
