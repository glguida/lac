(define defun (macro (name binds &rest body) `(define ,name (labels ,name ,binds ,@body))))
(define defmacro (macro (name binds &rest body) `(define ,name (macro ,binds ,@body))))
; a-la lisperati.com
(defmacro defspel (&rest rest) `(defmacro ,@rest))

(defun null (x) (eq x NIL))

(defun caar (x) (car (car x)))
(defun cadr (x) (car (cdr x)))
(defun cdar (x) (cdr (car x)))
(defun cddr (x) (cdr (cdr x)))
(defun caaar (x) (car (car (car x))))
(defun caadr (x) (car (car (cdr x))))
(defun cadar (x) (car (cdr (car x))))
(defun caddr (x) (car (cdr (cdr x))))
(defun cdaar (x) (cdr (car (car x))))
(defun cdadr (x) (cdr (car (cdr x))))
(defun cddar (x) (cdr (cdr (car x))))
(defun cdddr (x) (cdr (cdr (cdr x))))

(defun nthcdr (n l)
       (cond ((eq n 0) l)
       	     (t        (nthcdr (- n 1) (cdr l)))))
(defun nth (n l)
       (car (nthcdr n l)))

(defun first (l) (car l))
(defun second (l) (first (cdr l)))
(defun third (l) (second (cdr l)))
(defun fourth (l) (third (cdr l)))
(defun fifth (l) (fourth (cdr l)))
(defun sixth (l) (fifth (cdr l)))
(defun seventh (l) (sixth (cdr l)))
(defun eighth (l) (seventh (cdr l)))
(defun ninth (l) (eighth (cdr l)))
(defun tenth (l) (ninth (cdr l)))

;(defmacro let (binds &rest body) 
;  `((lambda ,(mapcar car binds) ,@body)
;    ,@(mapcar cadr binds)))

(defmacro if (test true false)
  `(cond (,test ,true) (t ,false)))

(defun not (x)
  (cond (x ())
	(t)))

(defmacro or (x &rest y)
	  `(cond ((not (eq ,x ())) T)
	  	 (t ,(if y
		    	 `(or ,@y)
			 ()))))

(defmacro and (x &rest y)
	  `(cond ((eq ,x NIL) NIL)
	  	 (t ,(if y
		    	 `(and ,@y)
			 t))))

(defun last (x) (cond ((null (cdr x)) x) (t (last (cdr x)))))

(defun length (lst)
  (if (null lst)
      0
    (+ 1 (length (cdr lst)))))

(defun member (el lst)
  (if (null lst) 
      NIL 
      (or (eq (car lst) el) (member el (cdr lst)))))

;(defun append (&rest llst)
;  (let ((lst (car llst))
;	(lsts (cdr llst)))
;    (cond
;      ((null lsts) lst)
;      ((eq 1 (length lst)) (cons (car lst) (apply append lsts)))
;      (t (cons (car lst)
;	       (append (cdr lst) (apply append lsts)))))))

(defun remove-if (test lst) 
  (if (null lst) 
      NIL 
      (if (test (car lst)) 
	  (remove-if test (cdr lst)) 
	  (cons (car lst) (remove-if test (cdr lst)))))) 

(defun remove-if-not (test lst)
  (remove-if (lambda (x) (not (test x))) lst))
 

(defun list (x &rest y) (cons x y))
(defmacro push (x place) 
  (list 'set (list 'quote place) (list 'cons x place)))


(defun listp (x) (or (null x) (consp x)))
(defun atomp (x) (not (consp x)))

(defun assq (s alist)
       (if (null alist) 
       	    NIL 
      	    (if (eq (caar alist) s)
	    	(car alist)
		(assq s (cdr alist)))))

(defmacro setq (sym val) 
	  `(set ',sym ,val))

(defun 1+ (x) (+ 1 x))
(defun 1- (x) (- x 1))
(defun evenp (x) (eq (% x 2) 0))
(defun oddp (x) (eq (% x 2) 1))
(defmacro incf (x) `(setq ,x (1+ ,x)))
(defmacro decf (x) `(setq ,x (1- ,x)))

(defun equal (x y) 
  (cond
    ((and (stringp x) (stringp y)) (string-equal x y))
    (t                             (eq x y))))

